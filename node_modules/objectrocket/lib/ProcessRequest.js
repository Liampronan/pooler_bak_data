var http = require('http');
var https = require('https');
var config = require('./config');

process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

/**
* ProcessRequest class defined for calling different methods.
* @class ProcessRequest
**/

function ProcessRequest() {
    var self = this;
    self.className = "ProcessRequest";
}

/**
* Processes the request after the validation of the input parameters and sends the response back to the end user.
* @method makeRequest
* @param {Object} parameters The required mandatory input parameters for making the remote request.
* @param {Function} callbackMethod The function to return the response after the processing is completed.
**/

ProcessRequest.prototype.makeRequest = function makeRequest(parameters, callbackMethod) {
    var self = this;
    if (arguments.callee.caller.name === "") {
        return self.errorResponse("Invalid method call", callbackMethod);
    }
    var userInput = {
        'options' : parameters,
        'caller_name' : arguments.callee.caller.name
    };
    var params = self.validateParams(userInput, callbackMethod);
    if(typeof params !== "object") {
        return params;
    }
    userInput = {};
    var options = {
        host : params.host,
        port : params.port,
        method : params.method
    };
    if (params.method === "GET") {
        options["path"] = params.path + "?" + params.parameter;
    } else {
        options["path"] = params.path;
        var header = {
            "content-type": "application/x-www-form-urlencoded",
            "content-length": params.parameter.length
        }
        options["headers"] = header;
    }
    var client = (params.protocol === "http") ? http : https;
    var request = client.request(options, function(response) {
        var result = '';
        response.on('data', function(chunk) {
            result += chunk;
        });
        response.on('end', function() {
            result = (typeof result === "object") ? JSON.stringify(result) : result;
            if (callbackMethod !== undefined) {
                callbackMethod(null, result);
            }
            return result;
        });
    });
    request.on('error', function(e) {
        return self.errorResponse(e.message, callbackMethod);
    });
    if (params.method === "POST") {
        request.write(params.parameter);
    }
    request.end();
}

/**
* Processes the parameters passed by the end user by comparing with the defined configuartion set in the config file to make the remote API call.
* @method validateParams
* @param {Object} params The required parameters passed by the client.
* @param {Function} callback The function to call after the processing is completed.
**/

ProcessRequest.prototype.validateParams = function validateParams(params, callback) {
    var self = this;
    var options = {};
    var url = "";
    var error_msg = "";
    var reqd_params = {
        'api_key' : true
    };
    if (arguments.callee.caller.name !== "makeRequest") {
        return self.errorResponse("Invalid method call", callback);
    } else {
        options = params.options;
        url = (config.path[params.caller_name] !== undefined) ? config.path[params.caller_name] : config.path["default"];
        url = url.replace("[%operation%]", (params.caller_name.indexOf("_data") !== -1) ? params.caller_name.substring(0, (params.caller_name.indexOf("_data"))) : params.caller_name);
    }
    if(callback === undefined || (callback !== undefined && typeof callback !== "function")) {
        return self.errorResponse("Callback is required as the second argument and must be a function");
    }
    try {
        if (typeof options !== "object") {
            options = JSON.parse(options);
        }
    } catch (err) {
        var errMsg = (JSON.stringify(err).length !== 2) ? " - " + JSON.stringify(err) : "";
        return self.errorResponse("Expected valid JSON format as an input" + errMsg, callback);
    }
    if (options instanceof Array || typeof options === "string") {
        return self.errorResponse("Input paramaters should be passed as a valid JSON object", callback);
    }
    error_msg = (options.api_key === undefined) ? "API Key is missing" : ((typeof options.api_key !== "string") ? "API Key should not be an object" : ((options.api_key.trim() === "") ? "API Key is blank" : ""));
    if(error_msg === "" && params.caller_name in config.mandatory_params) {
        for(var i = 0; i < config.mandatory_params[params.caller_name].length; i++) {
            error_msg = (config.mandatory_params[params.caller_name][i] in options) ? ((options[config.mandatory_params[params.caller_name][i]] instanceof Array || typeof options[config.mandatory_params[params.caller_name][i]] === "string") ? "'" + config.mandatory_params[params.caller_name][i] + "' passed should be an object" : ((Object.keys(options[config.mandatory_params[params.caller_name][i]]).length === 0) ? "'" + config.mandatory_params[params.caller_name][i] + "' passed is blank" : "")) : "'" + config.mandatory_params[params.caller_name][i] + "' is missing";
            if(error_msg.length !== 0) {
                break;
            }
            reqd_params[config.mandatory_params[params.caller_name][i]] = true;
        }
    }
    if(error_msg !== "") {
        return self.errorResponse(error_msg, callback);
    }
    var queryStr = "";
    var error = false;
    for(var key in options) {
        if (key in reqd_params && config.parameters[key] !== undefined) {
            queryStr += config.parameters[key].replace("[%" + key + "%]", (typeof options[key] === "object") ? JSON.stringify(options[key]) : options[key]) + "&";
        } else if(url.indexOf("[%" + key + "%]") !== -1) {
            url = (typeof options[key] !== "string" || options[key].trim() === "") ? null : url.replace("[%" + key + "%]", options[key].trim());
            if(url === null) {
                error = true;
                error_msg = "'" + key + "' name passed is either not a valid string or blank";
                break;
            }
        }
    }
    if(error) {
        return self.errorResponse(error_msg, callback);
    }
    if (url.indexOf("[%") !== -1) {
        return self.errorResponse("DB/Collection name is missing", callback);
    }
    if (queryStr[queryStr.length-1] === "&") {
        queryStr = queryStr.slice(0,-1);
    }
    var parameter = {
        "host" : config.host,
        "port" : (options.protocol !== undefined && options.protocol === "https") ? config.https_port : config.port,
        'method' : (options.method !== undefined && options.method === "GET") ? "GET" : "POST",
        "path" : url,
        "parameter" : queryStr,
        "protocol" : (options.protocol !== undefined && options.protocol === "https") ? "https" : "http"
    };
    return parameter;
}

/**
* Return the error message to the client.
* @method errorResponse
* @param {String} msg The reason for which the error occurred.
* @param {Function} callback The function to send back the response after the error situation.
**/

ProcessRequest.prototype.errorResponse = function(msg, callback) {
    var self = this;
    var error = {
        "msg" : msg,
        "rc" : 1
    };
    error = JSON.stringify(error);
    if (callback !== undefined) {
        callback(error, null);
    }
    return error;
}

module.exports = ProcessRequest;
